<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4022.18">
  <POU Name="FB_Read70x1CoeData" Id="{3d4514dc-8223-47db-9879-899720aca4f2}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_Read70x1CoeData
VAR_INPUT
   userNetId             : T_AmsNetId := ''; // Have to be entered
END_VAR
VAR_OUTPUT
    aCoeData : ARRAY[0..9] OF DUT_70x1CoeData;
    userSlaveAddr         : POINTER TO UINT;
END_VAR
VAR_IN_OUT
END_VAR
VAR
   fb_coe_read           : FB_EcCoESdoRead;  // Function Block for reading from CoE
   fb_get_secondaries   : FB_FindSecondaryAddr;  // Function Block for reading Secondary Addresses
   fb_filter_secondaries : FB_FilterSecondaries;

   nNumCoeParam           : BYTE := 6;
   bInit               : BOOL := TRUE;  // Kicks off Secondary Address read.
   aCoeIndex           : ARRAY[0..5] OF BYTE := [1, 2, 3, 6, 5, 0];
   aCoeAddr            : ARRAY[0..5] OF WORD :=   [16#8010, 16#8010, 16#8010, 16#8010, 16#8012, 16#1008];
   //userSlaveAddr         : POINTER TO UINT;     // Secondary Address
   startRead             : BOOL := FALSE;    // Sign for start reading CoE
   eState   			: E_State := E_State.Init;
   int16Buffer           : INT;              // Buffer for reading
   nReadIndex           : BYTE :=  0;
   nSlaveIndex          : BYTE := 0;
   nSlaves              : UINT := 0;
   pDstBuf              :   POINTER TO WORD;
   cbBufLen   : UDINT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[CASE eState OF
E_State.Init:
   fb_get_secondaries(userNetId:=userNetId, bExecute:= bInit);
   bInit := FALSE;
//Needs Error Checking
   IF NOT fb_get_secondaries.bBusy THEN
        userSlaveAddr := ADR(fb_get_secondaries.userSlaveAddr);
        nSlaves := fb_get_secondaries.nSlaves;
   END_IF
   IF startRead AND NOT fb_get_secondaries.bBusy THEN
        eState := E_State.PreRead;
   END_IF
E_State.PreRead:
      //fb_filter_secondaries(userNetId:= userNetId, bExecute:=TRUE, aAddr:= userSlaveAddr, bExecute:= TRUE, nAddrSize:= nSlaves);
      //IF NOT fb_filter_secondaries.bBusy THEN
      eState := E_State.Read;// Next state for reading
      fb_coe_read(bExecute := FALSE);// Prepare CoE-Access: Read an object/ sub index
      startRead := FALSE;
      //END_IF

E_State.Read:

     CASE nReadIndex OF
       0:
         pDstBuf := ADR(aCoeData[nSlaveIndex].nMaxCurrent);
       1:
         pDstBuf := ADR(aCoeData[nSlaveIndex].nReducedCurrent);
       2:
         pDstBuf := ADR(aCoeData[nSlaveIndex].nNominalVoltage);
       3:
         pDstBuf := ADR(aCoeData[nSlaveIndex].nMotorFullSteps);
       4:
         pDstBuf := ADR(aCoeData[nSlaveIndex].nSpeedRange);
       5:
         pDstBuf := ADR(aCoeData[nSlaveIndex].sDeviceName);
     END_CASE
    IF nReadIndex = 5 THEN
    cbBufLen := 80;
    ELSE
    cbBufLen := SIZEOF(pDstBuf^);
    END_IF
   // Read entry
   fb_coe_read(
   sNetId:= userNetId,
   nSlaveAddr:= userSlaveAddr[nSlaveIndex],
   nSubIndex:= aCoeIndex[nReadIndex],
   nIndex:= aCoeAddr[nReadIndex],
   pDstBuf:= pDstBuf,
   cbBufLen:= cbBufLen,
   bExecute:= TRUE,
   tTimeout:= T#1S
   );
   eState := E_State.Idle; // Next state
E_State.Idle:
   fb_coe_read();        // Execute CoE read until done
   IF fb_coe_read.bError THEN
      eState := E_State.Error;     // Error case
   ELSE
      IF NOT fb_coe_read.bBusy THEN
             eState := E_State.Init;
             IF nReadIndex < nNumCoeParam - 1 THEN
                startRead := TRUE;
                nReadIndex := nReadIndex + 1;
             ELSIF nReadIndex = nNumCoeParam - 1 AND nSlaveIndex < nSlaves - 1 THEN
                nReadIndex := 0;
                nSlaveIndex := nSlaveIndex + 1;
                startRead := TRUE;
             ELSE
                //nReadIndex := 0;
                //nSlaveIndex := 0;
             END_IF
         END_IF
   END_IF
E_State.Error:
    IF fb_coe_read.nErrId = 13
     or fb_coe_read.nErrId = 1797
        or fb_coe_read.nErrId = 1795 THEN
        //ERR_PORTNOTCONNECTED wasnt supported.
        //ADSERR_DEVICE_INVALIDSIZE, not an el 70x1
        //ADSERR_DEVICE_INVALIDOFFSET
        IF nSlaveIndex < nSlaves - 1 THEN
            nSlaveIndex := nSlaveIndex + 1;
            estate := E_State.Init;
            startRead := TRUE;
        END_IF
    END_IF

                  // Access error
END_CASE]]></ST>
    </Implementation>
  </POU>
</TcPlcObject>